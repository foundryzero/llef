"""Utility functions."""

import shutil
from argparse import ArgumentTypeError
from typing import List, Tuple

from lldb import (
    SBAddress,
    SBError,
    SBExecutionContext,
    SBFrame,
    SBMemoryRegionInfo,
    SBMemoryRegionInfoList,
    SBProcess,
    SBTarget,
    SBValue,
    SBExpressionOptions,
    eNoDynamicValues,
    eLanguageTypeObjC_plus_plus,
    value
    
)

from common.constants import DEFAULT_TERMINAL_COLUMNS, MAGIC_BYTES, MSG_TYPE, TERM_COLORS
from common.output_util import print_message
from common.state import LLEFState


def terminal_columns() -> int:
    return shutil.get_terminal_size().columns or DEFAULT_TERMINAL_COLUMNS


def address_to_filename(target: SBTarget, address: int) -> str:
    """
    Maps a memory address to its corrosponding executable/library and returns the filename.

    :param target: The target context.
    :param address: The memory address to resolve.
    :return: The filename.
    """
    sb_address = SBAddress(address, target)
    module = sb_address.GetModule()
    file_spec = module.GetSymbolFileSpec()
    filename = file_spec.GetFilename()

    return filename


def get_frame_range(frame: SBFrame, target: SBTarget) -> Tuple[str, str]:
    function = frame.GetFunction()
    if function:
        start_address = function.GetStartAddress().GetLoadAddress(target)
        end_address = function.GetEndAddress().GetLoadAddress(target)
    else:
        start_address = frame.GetSymbol().GetStartAddress().GetLoadAddress(target)
        end_address = frame.GetSymbol().GetEndAddress().GetLoadAddress(target) - 1

    return start_address, end_address


def get_registers(frame: SBFrame, frame_type: str) -> List[SBValue]:
    """
    Returns the registers in @frame that are of the specified @type.
    A @type is a string defined in LLDB, e.g. "General Purpose"
    """
    registers = []
    for regs in frame.GetRegisters():
        if frame_type.lower() in regs.GetName().lower():
            registers = regs
    return registers


def get_frame_arguments(frame: SBFrame, frame_argument_name_color: TERM_COLORS) -> str:
    """
    Returns a string containing args of the supplied frame
    """
    # GetVariables(arguments, locals, statics, in_scope_only)
    variables = frame.GetVariables(True, False, False, True)
    args = []
    for var in variables:
        # get and format argument value
        value = "???"
        var_value = var.GetValue()
        if var_value is None:
            value = "null"
        elif var_value:
            try:
                value = f"{int(var.GetValue(), 0):#x}"
            except ValueError:
                pass
        args.append(f"{frame_argument_name_color.value}{var.GetName()}{TERM_COLORS.ENDC.value}={value}")
    return f"({' '.join(args)})"


def attempt_to_read_string_from_memory(process: SBProcess, addr: SBValue, buffer_size: int = 256) -> str:
    """
    Returns a string from a memory address if one can be read, else an empty string
    """
    err = SBError()
    ret_string = ""
    try:
        string = process.ReadCStringFromMemory(addr, buffer_size, err)
        if err.Success() and string.isprintable():
            ret_string = string
    except SystemError:
        # This swallows an internal error that is sometimes generated by a bug in LLDB.
        pass
    return ret_string


def is_ascii_string(address: SBValue, process: SBProcess) -> bool:
    """
    Determines if a given memory @address contains a readable string.

    :param address: The memory address to read.
    :param process: A running process of the target.
    :return: A boolean of the check.
    """
    return attempt_to_read_string_from_memory(process, address) != ""


def is_in_section(address: SBValue, target: SBTarget, target_section_name: str) -> bool:
    """
    Determines whether a given memory @address exists within a @section of the executable file @target.

    The section's parents are searched to generate a full section name (e.g., __TEXT.__c_string).

    :param address: The memory address to check.
    :param target: The target object file.
    :param section: The section of the executable file.
    :return: A boolean of the check.
    """

    sb_address = target.ResolveLoadAddress(address)
    section = sb_address.GetSection()
    full_section_name = ""
    while section:
        full_section_name = section.GetName() + "." + full_section_name
        section = section.GetParent()

    return target_section_name in full_section_name


def is_text_region(address: SBValue, target: SBTarget, region: SBMemoryRegionInfo) -> bool:
    """
    Determines if a given memory @address if within a '.text' section of the target executable.

    :param address: The memory address to check.
    :param target: The target object file.
    :param region: The memory region that the address exists in.
    :return: A boolean of the check.
    """

    in_text = False
    if is_file(target, MAGIC_BYTES.MACH.value):
        if is_in_section(address, target, "__TEXT"):
            in_text = True
    else:
        file = target.GetExecutable()
        if is_in_section(address, target, ".text") or (
            file.GetFilename() in region.GetName() and file.GetDirectory() in region.GetName()
        ):
            in_text = True

    return in_text


def is_code(address: SBValue, process: SBProcess, target: SBTarget, regions: SBMemoryRegionInfoList) -> bool:
    """Determines whether an @address points to code"""
    region = SBMemoryRegionInfo()
    code_bool = False
    if regions is not None and regions.GetMemoryRegionContainingAddress(address, region):
        code_bool = region.IsExecutable() and is_text_region(
            address, target, region
        )  # and not is_ascii_string(address, process)
    return code_bool


def is_stack(address: SBValue, regions: SBMemoryRegionInfoList, stack_regions: List[SBMemoryRegionInfo]) -> bool:
    """Determines whether an @address points to the stack"""

    stack_bool = False
    region = SBMemoryRegionInfo()
    if regions is not None and regions.GetMemoryRegionContainingAddress(address, region):
        if LLEFState.platform == "Darwin" and region in stack_regions:
            stack_bool = True
        elif region.GetName() == "[stack]":
            stack_bool = True

    return stack_bool


def is_heap(
    address: SBValue, target: SBTarget, regions: SBMemoryRegionInfoList, darwin_heap_regions: List[Tuple[int, int]]
) -> bool:
    """Determines whether an @address points to the heap"""
    heap_bool = False
    if LLEFState.platform == "Darwin":
        for (lo, hi) in darwin_heap_regions:
            # print(f"{lo:x} > {address:x} > {hi:x}?")
            if address >= lo and address < hi:
                return True 
    else:
        region = SBMemoryRegionInfo()
        if regions is not None and regions.GetMemoryRegionContainingAddress(address, region):
            if region.GetName() == "[heap]":
                heap_bool = True
    return heap_bool


def extract_arch_from_triple(triple: str) -> str:
    """Extracts the architecture from triple string."""
    return triple.split("-")[0]


def verify_version(version: List[int], target_version: List[int]) -> bool:
    """Checks if the @version is greater than or equal to the @target_version."""
    length_difference = len(target_version) - len(version)
    if length_difference > 0:
        version += [0] * length_difference
    elif length_difference < 0:
        target_version += [0] * abs(length_difference)

    return version >= target_version


def lldb_version_to_clang(lldb_version):
    """
    Convert an LLDB version to its corrosponding Clang version.

    :param lldb_version: The LLDB version.
    :return: The Clang version.
    """

    clang_version = [0]
    if verify_version(lldb_version, [17, 0, 6]):
        clang_version = [1600, 0, 26, 3]
    elif verify_version(lldb_version, [16, 0, 0]):
        clang_version = [1500, 0, 40, 1]
    elif verify_version(lldb_version, [15, 0, 0]):
        clang_version = [1403, 0, 22, 14, 1]

    return clang_version


def check_version(required_version_string):
    def inner(func):
        def wrapper(*args, **kwargs):
            required_version = [int(x) for x in required_version_string.split(".")]
            if LLEFState.platform == "Darwin":
                required_version = lldb_version_to_clang(required_version)
            if not verify_version(LLEFState.version, required_version):
                print(f"error: requires LLDB version {required_version_string} to execute")
                return
            return func(*args, **kwargs)

        return wrapper

    return inner


def check_process(func):
    """
    Checks that there's a running process before executing the wrapped function. Only to be used on
    overrides of `__call__`.

    :param func: Wrapped function to be executed after successful check.
    """

    def wrapper(*args, **kwargs):
        for arg in list(args) + list(kwargs.values()):
            if isinstance(arg, SBExecutionContext):
                if arg.process.is_alive:
                    return func(*args, **kwargs)

                print_message(MSG_TYPE.ERROR, "Requires a running process.")
                return

        print_message(MSG_TYPE.ERROR, "Execution context not found.")

    return wrapper


def check_target(func):
    def wrapper(*args, **kwargs):
        for arg in list(args) + list(kwargs.values()):
            if isinstance(arg, SBExecutionContext):
                if arg.target.IsValid():
                    return func(*args, **kwargs)

                print_message(MSG_TYPE.ERROR, "Requires a valid target.")
                return

        print_message(MSG_TYPE.ERROR, "Execution context not found.")

    return wrapper


def is_file(target: SBTarget, expected_magic_bytes: List[bytes]):
    """Read signature of @target file and compare to expected magic bytes."""
    magic_bytes = read_program(target, 0, 4)
    return magic_bytes in expected_magic_bytes


def check_elf(func):
    def wrapper(*args, **kwargs):
        for arg in list(args) + list(kwargs.values()):
            if isinstance(arg, SBExecutionContext):
                try:
                    if is_file(arg.target, MAGIC_BYTES.ELF.value):
                        return func(*args, **kwargs)
                    else:
                        print_message(MSG_TYPE.ERROR, "Target must be an ELF file.")
                        return
                except MemoryError:
                    print_message(MSG_TYPE.ERROR, "couldn't determine file type")
                    return

        print_message(MSG_TYPE.ERROR, "Execution context not found.")

    return wrapper


def hex_int(x):
    """A converter for input arguments in different bases to ints.
    For base 0, the base is determined by the prefix. So, numbers starting `0x` are hex
    and numbers with no prefix are decimal. Base 0 also disallows leading zeros.
    """
    return int(x, 0)


def positive_int(x):
    """A converter for input arguments in different bases to positive ints"""
    x = hex_int(x)
    if x <= 0:
        raise ArgumentTypeError("Must be positive")
    return x


def hex_or_str(x):
    """Convert to formated hex if an integer, otherwise return the value."""
    if isinstance(x, int):
        return f"0x{x:016x}"

    return x


def read_program(target: SBTarget, offset: int, n: int):
    """
    Read @n bytes from a given @offset from the start of @target object file.

    :param target: The target object file.
    :param offset: The byte offset of the file to start reading from.
    :param n: The number of bytes to read from the offset.
    :return: The read bytes convert to an integer with little endianness.
    """

    error = SBError()
    # Executable has always been observed at module 0, but isn't specifically stated in docs.
    program_module = target.GetModuleAtIndex(0)
    address = program_module.GetObjectFileHeaderAddress()
    address.OffsetAddress(offset)
    data = target.ReadMemory(address, n, error)

    if error.Fail():
        raise MemoryError(f"Couldn't read memory at file offset {hex(address.GetOffset())}.")

    return data


def read_program_int(target: SBTarget, offset: int, n: int):
    """
    Read @n bytes from a given @offset from the start of @target object file,
    and convert to integer by little endian.

    :param target: The target object file.
    :param offset: The byte offset of the file to start reading from.
    :param n: The number of bytes to read from the offset.
    :return: The read bytes convert to an integer with little endianness.
    """

    data = read_program(target, offset, n)
    return int.from_bytes(data, "little")


def find_stack_regions(process: SBProcess) -> List[SBMemoryRegionInfo]:
    """
    Find all memory regions containing the stack by looping through stack pointers in each frame.

    :return: A list of memory region objects.
    """
    stack_regions = []
    for frame in process.GetSelectedThread().frames:
        sp = frame.GetSP()
        region = SBMemoryRegionInfo()
        process.GetMemoryRegionInfo(sp, region)
        stack_regions.append(region)

    return stack_regions

def find_darwin_heap_regions(process: SBProcess) -> List[SBMemoryRegionInfo]:
    """
    Find all memory regions containing the stack by looping through stack pointers in each frame.

    :return: A list of memory region objects.
    """
    # Reverse engineered from https://github.com/llvm-mirror/lldb/blob/master/examples/darwin/heap_find/heap.py
    # Is essentially modified malloc_info just for regions
    # Additional info from  https://github.com/apple-oss-distributions/libmalloc/blob/main/include/malloc/malloc.h#L456
    max_matches = 32
    expr = """
/* type defs */
typedef unsigned natural_t;
typedef uintptr_t vm_size_t;
typedef uintptr_t vm_address_t;
typedef natural_t task_t;
typedef int kern_return_t;
#define KERN_SUCCESS 0


/* malloc enumeration setup */
typedef void (*range_callback_t)(task_t task, void *baton, unsigned type, uintptr_t ptr_addr, uintptr_t ptr_size);
#define MALLOC_PTR_REGION_RANGE_TYPE	2	/* for region containing pointers */
typedef struct vm_range_t {
    vm_address_t address;
    vm_size_t size;
} vm_range_t;
typedef kern_return_t (*memory_reader_t)(task_t task, vm_address_t remote_address, vm_size_t size, void **local_memory);
typedef void (*vm_range_recorder_t)(task_t task, void *baton, unsigned type, vm_range_t *range, unsigned size);
typedef struct malloc_introspection_t {
    kern_return_t (*enumerator)(task_t task, void *, unsigned type_mask, vm_address_t zone_address, memory_reader_t reader, vm_range_recorder_t recorder); /* enumerates all the malloc pointers in use */
} malloc_introspection_t;
typedef struct malloc_zone_t {
    void *reserved1[12];
    struct malloc_introspection_t	*introspect;
} malloc_zone_t;
memory_reader_t task_peek = [](task_t task, vm_address_t remote_address, vm_size_t size, void **local_memory) -> kern_return_t {
    *local_memory = (void*) remote_address;
    return KERN_SUCCESS;
};
vm_address_t *zones = 0;
unsigned int num_zones = 0;task_t task = 0;
kern_return_t err = (kern_return_t)malloc_get_all_zones (task, task_peek, &zones, &num_zones);

/* search callbac setupk */
#define MAX_MATCHES %u

struct $malloc_region {
    uintptr_t lo_addr;
    uintptr_t hi_addr;
};

typedef struct callback_baton_t {
    range_callback_t callback;
    unsigned num_matches;
    $malloc_region matches[MAX_MATCHES + 1]; // Null terminate
} callback_baton_t;

/* callback */
range_callback_t range_callback = [](task_t task, void *baton, unsigned type, uintptr_t ptr_addr, uintptr_t ptr_size) -> void {
    callback_baton_t *lldb_info = (callback_baton_t *)baton;
    /* upper limit for our array */
    if (lldb_info->num_matches < MAX_MATCHES) {
        uintptr_t lo = ptr_addr;
        uintptr_t hi = lo + ptr_size;
        /* add to list */
        lldb_info->matches[lldb_info->num_matches].lo_addr = lo;
        lldb_info->matches[lldb_info->num_matches].hi_addr = hi;
        lldb_info->num_matches++;

    }
};
callback_baton_t baton = { range_callback, 0, {0} };

if (KERN_SUCCESS == err)
{
    for (unsigned int i=0; i<num_zones; ++i)
    {
        /* for all heap zones */
        const malloc_zone_t *zone = (const malloc_zone_t *)zones[i];
        if (zone && zone->introspect)
            /* introspection API will call our callback for reach heap region (rather than each allocation as in malloc_info) */
            zone->introspect->enumerator (task,
                                          &baton,
                                          MALLOC_PTR_REGION_RANGE_TYPE,
                                          (vm_address_t)zone,
                                          task_peek,
                                          [] (task_t task, void *baton, unsigned type, vm_range_t *ranges, unsigned size) -> void
                                          {
                                              range_callback_t callback = ((callback_baton_t *)baton)->callback;
                                              for (unsigned i=0; i<size; ++i)
                                              {
                                                  callback (task, baton, type, ranges[i].address, ranges[i].size);
                                              }
                                          });
    }
}
/* return the value */
baton.matches
""" % max_matches
    # run the above c code
    frame = process.GetSelectedThread().GetSelectedFrame()
    expr_options = SBExpressionOptions()
    expr_options.SetIgnoreBreakpoints(True)
    expr_options.SetFetchDynamicValue(eNoDynamicValues)
    expr_options.SetTimeoutInMicroSeconds(
        5 * 1000 * 1000)  # 5 second timeout
    expr_options.SetTryAllThreads(False)
    expr_options.SetLanguage(eLanguageTypeObjC_plus_plus)
    expr_sbvalue = frame.EvaluateExpression(expr, expr_options)
    # print("expression result:")
    # print(expr_sbvalue)
    heap_regions = []

    if expr_sbvalue.error.Success():
        for idx in range(max_matches):
            match_value = value(expr_sbvalue)
            match_entry = match_value[idx]
            lo_addr = match_entry.lo_addr.sbvalue.unsigned
            hi_addr = match_entry.hi_addr.sbvalue.unsigned
            if lo_addr == 0:
                break
            heap_regions.append((lo_addr, hi_addr))

    return heap_regions
