"""Utility functions."""

import os
import shutil
from argparse import ArgumentTypeError
from collections.abc import Callable
from typing import Any, Union

from lldb import (
    SBAddress,
    SBError,
    SBExecutionContext,
    SBExpressionOptions,
    SBFrame,
    SBMemoryRegionInfo,
    SBMemoryRegionInfoList,
    SBProcess,
    SBTarget,
    SBValue,
    eLanguageTypeObjC_plus_plus,
    eNoDynamicValues,
    value,
)

from common.constants import DEFAULT_TERMINAL_COLUMNS, MAGIC_BYTES, MSG_TYPE, TERM_COLORS
from common.golang.util import go_find_func_name_offset, perform_go_functions
from common.output_util import print_message
from common.settings import LLEFSettings
from common.state import LLEFState


def terminal_columns() -> int:
    return shutil.get_terminal_size().columns or DEFAULT_TERMINAL_COLUMNS


def address_to_filename(target: SBTarget, address: int) -> str:
    """
    Maps a memory address to its corresponding executable/library and returns the filename.

    :param target: The target context.
    :param address: The memory address to resolve.
    :return: The filename.
    """
    sb_address = SBAddress(address, target)
    module = sb_address.GetModule()
    file_spec = module.GetSymbolFileSpec()
    filename = file_spec.GetFilename()

    if filename is None:
        filename = module.GetFileSpec().GetFilename()

    return filename


def get_frame_range(frame: SBFrame, target: SBTarget) -> tuple[int, int]:
    function = frame.GetFunction()
    if function:
        start_address = function.GetStartAddress().GetLoadAddress(target)
        end_address = function.GetEndAddress().GetLoadAddress(target)
    else:
        start_address = frame.GetSymbol().GetStartAddress().GetLoadAddress(target)
        end_address = frame.GetSymbol().GetEndAddress().GetLoadAddress(target) - 1

    return start_address, end_address


def get_registers(frame: SBFrame, frame_type: str) -> Union[SBValue, list[SBValue]]:
    """
    Returns the registers in @frame that are of the specified @type.
    A @type is a string defined in LLDB, e.g. "General Purpose"
    """
    registers: Union[SBValue, list[SBValue]] = []
    for regs in frame.GetRegisters():
        regs_name = regs.GetName()
        if regs_name is not None:
            if frame_type.lower() in regs_name.lower():
                registers = regs
    return registers


def get_funcinfo_from_frame(settings: LLEFSettings, target: SBTarget, frame: SBFrame) -> tuple[str, int]:
    """
    Retrieves a best-effort function name and offset the PC is within it, given the current frame.

    :param LLEFSettings settings: The LLEFSettings object for determining the Go support level.
    :param SBTarget target: The target associated with the current process. For converting file->load addresses.
    :param SBFrame frame: The debugger frame.
    :return tuple[str, int]: A pair of (function name, offset).
    """
    pc = frame.GetPC()  # Returns the load address
    if perform_go_functions(settings):
        pair = go_find_func_name_offset(pc)
        if pair[0]:
            return pair

    func = frame.GetFunction()
    if func:
        return (func.GetName(), pc - func.GetStartAddress().GetLoadAddress(target))
    return (frame.GetSymbol().GetName(), pc - frame.GetSymbol().GetStartAddress().GetLoadAddress(target))


def get_frame_arguments(frame: SBFrame, frame_argument_name_color: TERM_COLORS) -> str:
    """
    Returns a string containing args of the supplied frame
    """
    # GetVariables(arguments, locals, statics, in_scope_only)
    variables = frame.GetVariables(True, False, False, True)
    args = []
    for var in variables:
        # get and format argument value
        val = "???"
        var_value = var.GetValue()
        if var_value is None:
            val = "null"
        elif var_value:
            try:
                val = f"{int(var.GetValue(), 0):#x}"
            except ValueError:
                pass
        args.append(f"{frame_argument_name_color.value}{var.GetName()}{TERM_COLORS.ENDC.value}={val}")
    return f"({' '.join(args)})"


def attempt_to_read_string_from_memory(process: SBProcess, addr: int, buffer_size: int = 256) -> str:
    """
    Returns a string from a memory address if one can be read, else an empty string
    """
    err = SBError()
    ret_string = ""
    try:
        string = process.ReadCStringFromMemory(addr, buffer_size, err)
        if err.Success() and string.isprintable():
            ret_string = string
    except SystemError:
        # This swallows an internal error that is sometimes generated by a bug in LLDB.
        pass
    return ret_string


def is_ascii_string(address: int, process: SBProcess) -> bool:
    """
    Determines if a given memory @address contains a readable string.

    :param address: The memory address to read.
    :param process: A running process of the target.
    :return: A boolean of the check.
    """
    return attempt_to_read_string_from_memory(process, address) != ""


def is_in_section(address: int, target: SBTarget, target_section_name: str) -> bool:
    """
    Determines whether a given memory @address exists within a @section of the executable file @target.

    The section's parents are searched to generate a full section name (e.g., __TEXT.__c_string).

    :param address: The memory address to check.
    :param target: The target object file.
    :param section: The section of the executable file.
    :return: A boolean of the check.
    """

    sb_address = target.ResolveLoadAddress(address)
    section = sb_address.GetSection()
    full_section_name = ""
    while section:
        full_section_name = section.GetName() + "." + full_section_name
        section = section.GetParent()

    return target_section_name in full_section_name


def is_text_region(address: int, target: SBTarget, region: SBMemoryRegionInfo) -> bool:
    """
    Determines if a given memory @address if within a '.text' section of the target executable.

    :param address: The memory address to check.
    :param target: The target object file.
    :param region: The memory region that the address exists in.
    :return: A boolean of the check.
    """

    in_text = False
    if is_file(target, MAGIC_BYTES.MACH.value):
        if is_in_section(address, target, "__TEXT"):
            in_text = True
    else:
        file = target.GetExecutable()
        if is_in_section(address, target, ".text") or (
            file.GetFilename() in region.GetName() and file.GetDirectory() in region.GetName()
        ):
            in_text = True

    return in_text


def is_code(address: int, process: SBProcess, target: SBTarget, regions: Union[SBMemoryRegionInfoList, None]) -> bool:
    """Determines whether an @address points to code"""
    region = SBMemoryRegionInfo()
    code_bool = False
    if regions is not None and regions.GetMemoryRegionContainingAddress(address, region):
        code_bool = region.IsExecutable() and is_text_region(
            address, target, region
        )  # and not is_ascii_string(address, process)
    return code_bool


def is_stack(
    address: int, regions: Union[SBMemoryRegionInfoList, None], darwin_stack_regions: list[SBMemoryRegionInfo]
) -> bool:
    """Determines whether an @address points to the stack"""

    stack_bool = False
    region = SBMemoryRegionInfo()
    if regions is not None and regions.GetMemoryRegionContainingAddress(address, region):
        if LLEFState.platform == "Darwin" and region in darwin_stack_regions:
            stack_bool = True
        elif region.GetName() == "[stack]":
            stack_bool = True

    return stack_bool


def is_heap(
    address: int,
    target: SBTarget,
    regions: Union[SBMemoryRegionInfoList, None],
    stack_regions: list[SBMemoryRegionInfo],
    darwin_heap_regions: Union[list[tuple[int, int]], None],
) -> bool:
    """Determines whether an @address points to the heap"""
    heap_bool = False

    if darwin_heap_regions is not None:
        # Only set when platform is Darwin (iOS, MacOS, etc) and darwin heap scan is enabled in settings.
        for lo, hi in darwin_heap_regions:
            if address >= lo and address < hi:
                heap_bool = True
    else:
        region = SBMemoryRegionInfo()
        if regions is not None and regions.GetMemoryRegionContainingAddress(address, region):
            if LLEFState.platform == "Darwin":
                sb_address = SBAddress(address, target)
                filename = sb_address.GetModule().GetFileSpec().GetFilename()
                if filename is None and not is_stack(address, regions, stack_regions) and region.IsWritable():
                    heap_bool = True
            elif region.GetName() == "[heap]":
                heap_bool = True
    return heap_bool


def verify_version(version: list[int], target_version: list[int]) -> bool:
    """Checks if the @version is greater than or equal to the @target_version."""
    length_difference = len(target_version) - len(version)
    if length_difference > 0:
        version += [0] * length_difference
    elif length_difference < 0:
        target_version += [0] * abs(length_difference)

    return version >= target_version


def lldb_version_to_clang(lldb_version: list[int]) -> list[int]:
    """
    Convert an LLDB version to its corresponding Clang version.

    :param lldb_version: The LLDB version.
    :return: The Clang version.
    """

    clang_version = [0]
    if verify_version(lldb_version, [17, 0, 6]):
        clang_version = [1600, 0, 26, 3]
    elif verify_version(lldb_version, [16, 0, 0]):
        clang_version = [1500, 0, 40, 1]
    elif verify_version(lldb_version, [15, 0, 0]):
        clang_version = [1403, 0, 22, 14, 1]

    return clang_version


def check_version(required_version_string: str):
    def inner(func):
        def wrapper(*args, **kwargs):
            required_version = [int(x) for x in required_version_string.split(".")]
            if LLEFState.platform == "Darwin":
                required_version = lldb_version_to_clang(required_version)
            if not verify_version(LLEFState.version, required_version):
                print(f"error: requires LLDB version {required_version_string} to execute")
                return
            return func(*args, **kwargs)

        return wrapper

    return inner


def check_process(func: Callable[..., Any]) -> Callable[..., Any]:
    """
    Checks that there's a running process before executing the wrapped function. Only to be used on
    overrides of `__call__`.

    :param func: Wrapped function to be executed after successful check.
    """

    def wrapper(*args: Any, **kwargs: Any) -> Any:
        for arg in list(args) + list(kwargs.values()):
            if isinstance(arg, SBExecutionContext):
                if arg.process.is_alive:
                    return func(*args, **kwargs)

                print_message(MSG_TYPE.ERROR, "Requires a running process.")
                return

        print_message(MSG_TYPE.ERROR, "Execution context not found.")

    return wrapper


def check_target(func: Callable[..., Any]) -> Callable[..., Any]:
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        for arg in list(args) + list(kwargs.values()):
            if isinstance(arg, SBExecutionContext):
                if arg.target.IsValid():
                    return func(*args, **kwargs)

                print_message(MSG_TYPE.ERROR, "Requires a valid target.")
                return

        print_message(MSG_TYPE.ERROR, "Execution context not found.")

    return wrapper


def is_file(target: SBTarget, expected_magic_bytes: list[bytes]) -> bool:
    """Read signature of @target file and compare to expected magic bytes."""
    magic_bytes = read_program(target, 0, 4)
    return magic_bytes in expected_magic_bytes


def check_elf(func: Callable[..., Any]) -> Callable[..., Any]:
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        for arg in list(args) + list(kwargs.values()):
            if isinstance(arg, SBExecutionContext):
                try:
                    if is_file(arg.target, MAGIC_BYTES.ELF.value):
                        return func(*args, **kwargs)
                    else:
                        print_message(MSG_TYPE.ERROR, "Target must be an ELF file.")
                        return
                except MemoryError:
                    print_message(MSG_TYPE.ERROR, "couldn't determine file type")
                    return

        print_message(MSG_TYPE.ERROR, "Execution context not found.")

    return wrapper


def hex_int(x: str) -> int:
    """A converter for input arguments in different bases to ints.
    For base 0, the base is determined by the prefix. So, numbers starting `0x` are hex
    and numbers with no prefix are decimal. Base 0 also disallows leading zeros.
    """
    return int(x, 0)


def positive_int(x: str) -> int:
    """A converter for input arguments in different bases to positive ints"""
    int_x = hex_int(x)
    if int_x <= 0:
        raise ArgumentTypeError("Must be positive")
    return int_x


def hex_or_str(x: Union[str, int]) -> str:
    """Convert to formatted hex if an integer, otherwise return the value."""
    if isinstance(x, int):
        return f"0x{x:016x}"

    return x


def read_program(target: SBTarget, offset: int, n: int) -> bytes:
    """
    Read @n bytes from a given @offset from the start of @target object file.

    :param target: The target object file.
    :param offset: The byte offset of the file to start reading from.
    :param n: The number of bytes to read from the offset.
    :return: The read bytes convert to an integer with little endianness.
    """

    error = SBError()
    # Executable has always been observed at module 0, but isn't specifically stated in docs.
    program_module = target.GetModuleAtIndex(0)
    address = program_module.GetObjectFileHeaderAddress()
    address.OffsetAddress(offset)
    data = target.ReadMemory(address, n, error)

    if error.Fail() or data is None:
        raise MemoryError(f"Couldn't read memory at file offset {hex(address.GetOffset())}.")

    return data


def read_program_int(target: SBTarget, offset: int, n: int) -> int:
    """
    Read @n bytes from a given @offset from the start of @target object file,
    and convert to integer by little endian.

    :param target: The target object file.
    :param offset: The byte offset of the file to start reading from.
    :param n: The number of bytes to read from the offset.
    :return: The read bytes convert to an integer with little endianness.
    """

    data = read_program(target, offset, n)
    return int.from_bytes(data, "little")


def find_stack_regions(process: SBProcess) -> list[SBMemoryRegionInfo]:
    """
    Find all memory regions containing the stack by looping through stack pointers in each frame.

    :return: A list of memory region objects.
    """
    stack_regions = []
    for frame in process.GetSelectedThread().frames:
        sp = frame.GetSP()
        region = SBMemoryRegionInfo()
        process.GetMemoryRegionInfo(sp, region)
        stack_regions.append(region)

    return stack_regions


def find_darwin_heap_regions(process: SBProcess) -> Union[list[tuple[int, int]], None]:
    """
    Find memory heap regions on Darwin.

    :return: list[tuple[int, int]]: A list containing values for min and max ranges for heap regions on Darwin.
    """

    MAX_MATCHES = 128

    # Define Objective C++ code to be run as an LLDB expression.

    # Read template file, replace MAX_MATCHES value.
    common_dir = os.path.dirname(os.path.abspath(__file__))
    expr_file_path = os.path.join(common_dir, "expressions", "darwin_get_malloc_zones.mm")

    with open(expr_file_path, "r") as expr_file:
        expr = expr_file.read().replace("{{MAX_MATCHES}}", str(MAX_MATCHES))

    # Return SBFrame stack frame object from current thread.
    frame = process.GetSelectedThread().GetSelectedFrame()

    # Set options for evaluating Objective C++ code.
    expr_options = SBExpressionOptions()
    expr_options.SetIgnoreBreakpoints(True)
    expr_options.SetFetchDynamicValue(eNoDynamicValues)
    # Set a 3 second timeout.
    expr_options.SetTimeoutInMicroSeconds(3 * 1000 * 1000)
    expr_options.SetTryAllThreads(False)
    expr_options.SetLanguage(eLanguageTypeObjC_plus_plus)

    expr_sbvalue = frame.EvaluateExpression(expr, expr_options)
    match_value = value(expr_sbvalue)
    heap_regions = []

    # Populate heap regions from expression result.
    if expr_sbvalue.error.Success():
        for count in range(MAX_MATCHES):
            match_entry = match_value[count]
            lo_addr = match_entry.lo_addr.sbvalue.unsigned
            hi_addr = match_entry.hi_addr.sbvalue.unsigned
            if lo_addr != 0:
                heap_regions.append((lo_addr, hi_addr))
    else:
        # Fallback to default way to calculate heap regions in error condition.
        return None

    return heap_regions
