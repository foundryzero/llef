"""Utility functions."""

import os
from argparse import ArgumentTypeError
from typing import List, Tuple

from lldb import (
    SBAddress,
    SBError,
    SBExecutionContext,
    SBFrame,
    SBInstruction,
    SBMemoryRegionInfo,
    SBMemoryRegionInfoList,
    SBProcess,
    SBTarget,
    SBValue,
)

from common.constants import DEFAULT_TERMINAL_COLUMNS, MAGIC_BYTES, MSG_TYPE, TERM_COLORS
from common.output_util import print_message
from common.state import LLEFState


def terminal_columns() -> int:
    return os.get_terminal_size().columns or DEFAULT_TERMINAL_COLUMNS


def address_to_filename(target: SBTarget, address: int) -> str:
    """
    Maps a memory address to its corrosponding executable/library and returns the filename.

    :param target: The target context.
    :param address: The memory address to resolve.
    :return: The filename.
    """
    sb_address = SBAddress(address, target)
    module = sb_address.GetModule()
    file_spec = module.GetFileSpec()
    filename = file_spec.GetFilename()

    return filename


def extract_instructions(
    target: SBTarget, start_address: int, end_address: int, disassembly_flavour: str
) -> List[SBInstruction]:
    """
    Returns a list of instructions between a range of memory address defined by @start_address and @end_address.

    :param target: The target context.
    :param start_address: The address to start reading instructions from memory.
    :param end_address: The address to stop reading instruction from memory.
    :return: A list of instructions.
    """
    instructions = []
    current = start_address
    while current <= end_address:
        address = SBAddress(current, target)
        instruction = target.ReadInstructions(address, 1, disassembly_flavour).GetInstructionAtIndex(0)
        instructions.append(instruction)
        instruction_size = instruction.GetByteSize()
        if instruction_size > 0:
            current += instruction_size
        else:
            break

    return instructions


def get_frame_range(frame: SBFrame, target: SBTarget) -> Tuple[str, str]:
    function = frame.GetFunction()
    if function:
        start_address = function.GetStartAddress().GetLoadAddress(target)
        end_address = function.GetEndAddress().GetLoadAddress(target)
    else:
        start_address = frame.GetSymbol().GetStartAddress().GetLoadAddress(target)
        end_address = frame.GetSymbol().GetEndAddress().GetLoadAddress(target) - 1

    return start_address, end_address


def get_registers(frame: SBFrame, frame_type: str) -> List[SBValue]:
    """
    Returns the registers in @frame that are of the specified @type.
    A @type is a string defined in LLDB, e.g. "General Purpose"
    """
    registers = []
    for regs in frame.GetRegisters():
        if frame_type.lower() in regs.GetName().lower():
            registers = regs
    return registers


def get_frame_arguments(frame: SBFrame, frame_argument_name_color: TERM_COLORS) -> str:
    """
    Returns a string containing args of the supplied frame
    """
    # GetVariables(arguments, locals, statics, in_scope_only)
    variables = frame.GetVariables(True, False, False, True)
    args = []
    for var in variables:
        # get and format argument value
        value = "???"
        var_value = var.GetValue()
        if var_value is None:
            value = "null"
        elif var_value:
            try:
                value = f"{int(var.GetValue(), 0):#x}"
            except ValueError:
                pass
        args.append(f"{frame_argument_name_color.value}{var.GetName()}{TERM_COLORS.ENDC.value}={value}")
    return f"({' '.join(args)})"


def attempt_to_read_string_from_memory(process: SBProcess, addr: SBValue, buffer_size: int = 256) -> str:
    """
    Returns a string from a memory address if one can be read, else an empty string
    """
    err = SBError()
    ret_string = ""
    try:
        string = process.ReadCStringFromMemory(addr, buffer_size, err)
        if err.Success() and string.isprintable():
            ret_string = string
    except SystemError:
        # This swallows an internal error that is sometimes generated by a bug in LLDB.
        pass
    return ret_string


def is_ascii_string(address: SBValue, process: SBProcess) -> bool:
    """
    Determines if a given memory @address contains a readable string.

    :param address: The memory address to read.
    :param process: A running process of the target.
    :return: A boolean of the check.
    """
    return attempt_to_read_string_from_memory(process, address) != ""


def is_in_section(address: SBValue, target: SBTarget, target_section_name: str):
    """
    Determines whether a given memory @address exists within a @section of the executable file @target.

    :param address: The memory address to check.
    :param target: The target object file.
    :param section: The section of the executable file.
    :return: A boolean of the check.
    """

    sb_address = target.ResolveLoadAddress(address)
    section = sb_address.GetSection()
    section_name = section.GetName()

    return section_name is not None and target_section_name in section_name


def is_text_region(address: SBValue, target: SBTarget, region: SBMemoryRegionInfo) -> bool:
    """
    Determines if a given memory @address if within a '.text' section of the target executable.

    :param address: The memory address to check.
    :param target: The target object file.
    :param region: The memory region that the address exists in.
    :return: A boolean of the check.
    """

    in_text = False
    if is_file(target, MAGIC_BYTES.MACH.value):
        if is_in_section(address, target, "__TEXT") or is_in_section(address, target, "__text"):
            in_text = True
    else:
        file = target.GetExecutable()
        if is_in_section(address, target, ".text") or (
            file.GetFilename() in region.GetName() and file.GetDirectory() in region.GetName()
        ):
            in_text = True

    return in_text


def is_code(address: SBValue, process: SBProcess, target: SBTarget, regions: SBMemoryRegionInfoList) -> bool:
    """Determines whether an @address points to code"""
    region = SBMemoryRegionInfo()
    code_bool = False
    if regions is not None and regions.GetMemoryRegionContainingAddress(address, region):
        code_bool = region.IsExecutable() and is_text_region(
            address, target, region
        )  # and not is_ascii_string(address, process)
    return code_bool


def is_stack(address: SBValue, regions: SBMemoryRegionInfoList, stack_regions: List[SBMemoryRegionInfo]) -> bool:
    """Determines whether an @address points to the stack"""

    stack_bool = False
    region = SBMemoryRegionInfo()
    if regions is not None and regions.GetMemoryRegionContainingAddress(address, region):
        if LLEFState.platform == "Darwin" and region in stack_regions:
            stack_bool = True
        elif region.GetName() == "[stack]":
            stack_bool = True

    return stack_bool


def is_heap(
    address: SBValue, target: SBTarget, regions: SBMemoryRegionInfoList, stack_regions: List[SBMemoryRegionInfo]
) -> bool:
    """Determines whether an @address points to the heap"""
    heap_bool = False
    region = SBMemoryRegionInfo()
    if regions is not None and regions.GetMemoryRegionContainingAddress(address, region):
        if LLEFState.platform == "Darwin":
            sb_address = SBAddress(address, target)
            filename = sb_address.GetModule().GetFileSpec().GetFilename()
            if filename is None and not is_stack(address, regions, stack_regions) and region.IsWritable():
                heap_bool = True
        elif region.GetName() == "[heap]":
            heap_bool = True
    return heap_bool


def extract_arch_from_triple(triple: str) -> str:
    """Extracts the architecture from triple string."""
    return triple.split("-")[0]


def lldb_version_to_clang(lldb_version):
    """
    Convert an LLDB version to its corrosponding Clang version.

    :param lldb_version: The LLDB version.
    :return: The Clang version.
    """

    clang_version = [0, 0, 0, 0]
    if lldb_version >= [17, 0, 6]:
        clang_version = [1600, 0, 26, 3]
    elif lldb_version >= [16, 0, 0]:
        clang_version = [1500, 0, 40, 1]
    elif lldb_version >= [15, 0, 0]:
        clang_version = [1403, 0, 22, 14, 1]

    return clang_version


def check_version(required_version_string):
    def inner(func):
        def wrapper(*args, **kwargs):
            required_version = [int(x) for x in required_version_string.split(".")]
            if LLEFState.platform == "Darwin":
                required_version = lldb_version_to_clang(required_version)
            if LLEFState.version < required_version:
                print(f"error: requires LLDB version {required_version_string} to execute")
                return
            return func(*args, **kwargs)

        return wrapper

    return inner


def check_process(func):
    """
    Checks that there's a running process before executing the wrapped function. Only to be used on
    overrides of `__call__`.

    :param func: Wrapped function to be executed after successful check.
    """

    def wrapper(*args, **kwargs):
        for arg in list(args) + list(kwargs.values()):
            if isinstance(arg, SBExecutionContext):
                if arg.process.is_alive:
                    return func(*args, **kwargs)

                print_message(MSG_TYPE.ERROR, "Requires a running process.")
                return

        print_message(MSG_TYPE.ERROR, "Execution context not found.")

    return wrapper


def check_target(func):
    def wrapper(*args, **kwargs):
        for arg in list(args) + list(kwargs.values()):
            if isinstance(arg, SBExecutionContext):
                if arg.target.IsValid():
                    return func(*args, **kwargs)

                print_message(MSG_TYPE.ERROR, "Requires a valid target.")
                return

        print_message(MSG_TYPE.ERROR, "Execution context not found.")

    return wrapper


def is_file(target: SBTarget, expected_magic_bytes: List[bytes]):
    """Read signature of @target file and compare to expected magic bytes."""
    magic_bytes = read_program(target, 0, 4)
    return magic_bytes in expected_magic_bytes


def check_elf(func):
    def wrapper(*args, **kwargs):
        for arg in list(args) + list(kwargs.values()):
            if isinstance(arg, SBExecutionContext):
                try:
                    if is_file(arg.target, MAGIC_BYTES.ELF.value):
                        return func(*args, **kwargs)
                    else:
                        print_message(MSG_TYPE.ERROR, "Target must be an ELF file.")
                        return
                except MemoryError:
                    print_message(MSG_TYPE.ERROR, "couldn't determine file type")
                    return

        print_message(MSG_TYPE.ERROR, "Execution context not found.")

    return wrapper


def hex_int(x):
    """A converter for input arguments in different bases to ints.
    For base 0, the base is determined by the prefix. So, numbers starting `0x` are hex
    and numbers with no prefix are decimal. Base 0 also disallows leading zeros.
    """
    return int(x, 0)


def positive_int(x):
    """A converter for input arguments in different bases to positive ints"""
    x = hex_int(x)
    if x <= 0:
        raise ArgumentTypeError("Must be positive")
    return x


def hex_or_str(x):
    """Convert to formated hex if an integer, otherwise return the value."""
    if isinstance(x, int):
        return f"0x{x:016x}"

    return x


def read_program(target: SBTarget, offset: int, n: int):
    """
    Read @n bytes from a given @offset from the start of @target object file.

    :param target: The target object file.
    :param offset: The byte offset of the file to start reading from.
    :param n: The number of bytes to read from the offset.
    :return: The read bytes convert to an integer with little endianness.
    """

    error = SBError()
    # Executable has always been observed at module 0, but isn't specifically stated in docs.
    program_module = target.GetModuleAtIndex(0)
    address = program_module.GetObjectFileHeaderAddress()
    address.OffsetAddress(offset)
    data = target.ReadMemory(address, n, error)

    if error.Fail():
        raise MemoryError(f"Couldn't read memory at file offset {hex(address.GetOffset())}.")

    return data


def read_program_int(target: SBTarget, offset: int, n: int):
    """
    Read @n bytes from a given @offset from the start of @target object file,
    and convert to integer by little endian.

    :param target: The target object file.
    :param offset: The byte offset of the file to start reading from.
    :param n: The number of bytes to read from the offset.
    :return: The read bytes convert to an integer with little endianness.
    """

    data = read_program(target, offset, n)
    return int.from_bytes(data, "little")
