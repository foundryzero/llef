"""Utility functions."""

import os
from typing import List

from lldb import SBError, SBFrame, SBMemoryRegionInfo, SBMemoryRegionInfoList, SBProcess, SBValue

from common.constants import ALIGN, GLYPHS, MSG_TYPE, TERM_COLOURS


def clear_page() -> None:
    """
    Used to clear the previously printed breakpoint information before
    printing the next information.
    """
    num_lines = os.get_terminal_size().lines
    for _ in range(num_lines):
        print()
    print("\033[0;0H")  # Ansi escape code: Set cursor to 0,0 position
    print("\033[J")  # Ansi escape code: Clear contents from cursor to end of screen


def print_line_with_string(
    string: str,
    char: GLYPHS = GLYPHS.HORIZONTAL_LINE,
    line_colour: TERM_COLOURS = TERM_COLOURS.GREY,
    string_colour: TERM_COLOURS = TERM_COLOURS.BLUE,
    align: ALIGN = ALIGN.RIGHT,
) -> None:
    """Print a line with the provided @string padded with @char"""
    width = os.get_terminal_size().columns
    if align == ALIGN.RIGHT:
        l_pad = (width - len(string) - 6) * char.value
        r_pad = 4 * char.value

    elif align == ALIGN.CENTRE:
        l_pad = (width - len(string)) * char.value
        r_pad = 4 * char.value

    elif align == ALIGN.LEFT:
        l_pad = 4 * char.value
        r_pad = (width - len(string) - 6) * char.value

    print(
        f"{line_colour.value}{l_pad}{TERM_COLOURS.ENDC.value} "
        + f"{string_colour.value}{string}{TERM_COLOURS.ENDC.value} {line_colour.value}{r_pad}{TERM_COLOURS.ENDC.value}"
    )


def print_line(
    char: GLYPHS = GLYPHS.HORIZONTAL_LINE, colour: TERM_COLOURS = TERM_COLOURS.GREY
) -> None:
    """Print a line of @char"""
    print(
        f"{colour.value}{os.get_terminal_size().columns*char.value}{TERM_COLOURS.ENDC.value}"
    )


def print_message(msg_type: MSG_TYPE, message: str) -> None:
    """Format and print a @message"""
    if msg_type == MSG_TYPE.INFO:
        print(f"{TERM_COLOURS.BLUE.value}[+]{TERM_COLOURS.ENDC.value} {message}")
    elif msg_type == MSG_TYPE.SUCCESS:
        print(f"{TERM_COLOURS.GREEN.value}[+]{TERM_COLOURS.ENDC.value} {message}")
    elif msg_type == MSG_TYPE.ERROR:
        print(f"{TERM_COLOURS.RED.value}[+]{TERM_COLOURS.ENDC.value} {message}")


def print_instruction(line: str, color: TERM_COLOURS = TERM_COLOURS.ENDC) -> None:
    """Format and print a line of disassembly returned from LLDB (SBFrame.disassembly)"""
    loc_0x = line.find("0x")
    start_idx = loc_0x if loc_0x >= 0 else 0
    print(f"{color.value}{line[start_idx:]}{TERM_COLOURS.ENDC.value}")


def get_registers(frame: SBFrame, frame_type: str) -> List[SBValue]:
    """
    Returns the registers in @frame that are of the specified @type.
    A @type is a string defined in LLDB, e.g. "General Purpose"
    """
    registers = []
    for regs in frame.GetRegisters():
        if frame_type.lower() in regs.GetName().lower():
            registers = regs
    return registers


def get_frame_arguments(frame: SBFrame) -> str:
    """
    Returns a string containing args of the supplied frame
    """
    # GetVariables(arguments, locals, statics, in_scope_only)
    variables = frame.GetVariables(True, False, False, True)
    args = []
    for var in variables:
        # get and format argument value
        value = "???"
        var_value = var.GetValue()
        if var_value is None:
            value = "null"
        elif var_value:
            try:
                value = f"{int(var.GetValue(), 0):#x}"
            except ValueError:
                pass
        args.append(
            f"{TERM_COLOURS.YELLOW.value}{var.GetName()}{TERM_COLOURS.ENDC.value}={value}"
        )
    return f"({' '.join(args)})"


def attempt_to_read_string_from_memory(
    process: SBProcess, addr: SBValue, buffer_size: int = 256
) -> str:
    """
    Returns a string from a memory address if one can be read, else an empty string
    """
    err = SBError()
    ret_string = ""
    try:
        string = process.ReadCStringFromMemory(addr, buffer_size, err)
        if err.Success():
            ret_string = string
    except SystemError:
        # This swallows an internal error that is sometimes generated by a bug in LLDB.
        pass
    return ret_string


def is_code(address: SBValue, process: SBProcess, regions: SBMemoryRegionInfoList) -> bool:
    """Determines whether an @address points to code"""
    region = SBMemoryRegionInfo()
    code_bool = False
    if regions.GetMemoryRegionContainingAddress(address, region):
        code_bool = region.IsExecutable()
    return code_bool


def is_stack(address: SBValue, process: SBProcess, regions: SBMemoryRegionInfoList) -> bool:
    """Determines whether an @address points to the stack"""
    region = SBMemoryRegionInfo()
    stack_bool = False
    if regions.GetMemoryRegionContainingAddress(address, region):
        if region.GetName() == "[stack]":
            stack_bool = True
    return stack_bool


def is_heap(address: SBValue, process: SBProcess, regions: SBMemoryRegionInfoList) -> bool:
    """Determines whether an @address points to the heap"""
    region = SBMemoryRegionInfo()
    heap_bool = False
    if regions.GetMemoryRegionContainingAddress(address, region):
        if region.GetName() == "[heap]":
            heap_bool = True
    return heap_bool


def extract_arch_from_triple(triple: str) -> str:
    """Extracts the architecture from triple string."""
    return triple.split("-")[0]
