"""Utility functions."""

import os
import re
from typing import Any, List

from lldb import (
    SBError,
    SBExecutionContext,
    SBFrame,
    SBMemoryRegionInfo,
    SBMemoryRegionInfoList,
    SBProcess,
    SBSection,
    SBTarget,
    SBValue,
)

from common.constants import ALIGN, GLYPHS, MSG_TYPE, TERM_COLORS
from common.state import LLEFState


def change_use_color(new_value: bool) -> None:
    """
    Change the global use_color bool. use_color should not be written to directly
    """
    LLEFState.use_color = new_value


def output_line(line: Any) -> None:
    """
    Format a line of output for printing. Print should not be used elsewhere.
    Exception - clear_page would not function without terminal characters
    """
    line = str(line)
    ansi_escape = re.compile(r"\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])")
    if LLEFState.use_color is False:
        line = ansi_escape.sub("", line)
    print(line)


def clear_page() -> None:
    """
    Used to clear the previously printed breakpoint information before
    printing the next information.
    """
    num_lines = os.get_terminal_size().lines
    for _ in range(num_lines):
        print()
    print("\033[0;0H")  # Ansi escape code: Set cursor to 0,0 position
    print("\033[J")  # Ansi escape code: Clear contents from cursor to end of screen


def print_line_with_string(
    string: str,
    char: GLYPHS = GLYPHS.HORIZONTAL_LINE,
    line_color: TERM_COLORS = TERM_COLORS.GREY,
    string_color: TERM_COLORS = TERM_COLORS.BLUE,
    align: ALIGN = ALIGN.RIGHT,
) -> None:
    """Print a line with the provided @string padded with @char"""
    width = os.get_terminal_size().columns
    if align == ALIGN.RIGHT:
        l_pad = (width - len(string) - 6) * char.value
        r_pad = 4 * char.value

    elif align == ALIGN.CENTRE:
        l_pad = (width - len(string)) * char.value
        r_pad = 4 * char.value

    elif align == ALIGN.LEFT:
        l_pad = 4 * char.value
        r_pad = (width - len(string) - 6) * char.value

    output_line(
        f"{line_color.value}{l_pad}{TERM_COLORS.ENDC.value} "
        + f"{string_color.value}{string}{TERM_COLORS.ENDC.value} {line_color.value}{r_pad}{TERM_COLORS.ENDC.value}"
    )


def print_line(char: GLYPHS = GLYPHS.HORIZONTAL_LINE, color: TERM_COLORS = TERM_COLORS.GREY) -> None:
    """Print a line of @char"""
    output_line(f"{color.value}{os.get_terminal_size().columns * char.value}{TERM_COLORS.ENDC.value}")


def print_message(msg_type: MSG_TYPE, message: str) -> None:
    """Format and print a @message"""
    info_color = TERM_COLORS.BLUE
    success_color = TERM_COLORS.GREEN
    error_color = TERM_COLORS.GREEN

    if msg_type == MSG_TYPE.INFO:
        output_line(f"{info_color.value}[+]{TERM_COLORS.ENDC.value} {message}")
    elif msg_type == MSG_TYPE.SUCCESS:
        output_line(f"{success_color.value}[+]{TERM_COLORS.ENDC.value} {message}")
    elif msg_type == MSG_TYPE.ERROR:
        output_line(f"{error_color.value}[+]{TERM_COLORS.ENDC.value} {message}")


def print_instruction(line: str, color: TERM_COLORS = TERM_COLORS.ENDC) -> None:
    """Format and print a line of disassembly returned from LLDB (SBFrame.disassembly)"""
    loc_0x = line.find("0x")
    start_idx = loc_0x if loc_0x >= 0 else 0
    output_line(f"{color.value}{line[start_idx:]}{TERM_COLORS.ENDC.value}")


def get_registers(frame: SBFrame, frame_type: str) -> List[SBValue]:
    """
    Returns the registers in @frame that are of the specified @type.
    A @type is a string defined in LLDB, e.g. "General Purpose"
    """
    registers = []
    for regs in frame.GetRegisters():
        if frame_type.lower() in regs.GetName().lower():
            registers = regs
    return registers


def get_frame_arguments(frame: SBFrame, frame_argument_name_color: TERM_COLORS) -> str:
    """
    Returns a string containing args of the supplied frame
    """
    # GetVariables(arguments, locals, statics, in_scope_only)
    variables = frame.GetVariables(True, False, False, True)
    args = []
    for var in variables:
        # get and format argument value
        value = "???"
        var_value = var.GetValue()
        if var_value is None:
            value = "null"
        elif var_value:
            try:
                value = f"{int(var.GetValue(), 0):#x}"
            except ValueError:
                pass
        args.append(f"{frame_argument_name_color.value}{var.GetName()}{TERM_COLORS.ENDC.value}={value}")
    return f"({' '.join(args)})"


def attempt_to_read_string_from_memory(process: SBProcess, addr: SBValue, buffer_size: int = 256) -> str:
    """
    Returns a string from a memory address if one can be read, else an empty string
    """
    err = SBError()
    ret_string = ""
    try:
        string = process.ReadCStringFromMemory(addr, buffer_size, err)
        if err.Success():
            ret_string = string
    except SystemError:
        # This swallows an internal error that is sometimes generated by a bug in LLDB.
        pass
    return ret_string


def is_ascii_string(address: SBValue, process: SBProcess) -> bool:
    """
    Determines if a given memory @address contains a readable string.

    :param address: The memory address to read.
    :param process: A running process of the target.
    :return: A boolean of the check.
    """
    return attempt_to_read_string_from_memory(process, address) != ""


def is_in_section(address: SBValue, target: SBTarget, section: SBSection):
    """
    Determines whether a given memory @address exists within a @section of the executable file @target.

    :param address: The memory address to check.
    :param target: The target object file.
    :param section: The section of the executable file.
    :return: A boolean of the check.
    """

    if section:
        section_start = section.GetLoadAddress(target)
        section_end = section_start + section.GetByteSize()
        if section_start <= address < section_end:
            return True

    return False


def is_text_region(address: SBValue, target: SBTarget, region: SBMemoryRegionInfo) -> bool:
    """
    Determines if a given memory @address if within a '.text' section of the target executable.

    :param address: The memory address to check.
    :param target: The target object file.
    :param region: The memory region that the address exists in.
    :return: A boolean of the check.
    """
    file = target.GetExecutable()
    text_section = target.GetModuleAtIndex(0).FindSection(".text")

    in_text = False
    if is_in_section(address, target, text_section):
        in_text = True
    elif file.GetFilename() in region.GetName() and file.GetDirectory() in region.GetName():
        in_text = True

    return in_text


def is_code(address: SBValue, process: SBProcess, target: SBTarget, regions: SBMemoryRegionInfoList) -> bool:
    """Determines whether an @address points to code"""
    region = SBMemoryRegionInfo()
    code_bool = False
    if regions is not None and regions.GetMemoryRegionContainingAddress(address, region):
        code_bool = region.IsExecutable() and is_text_region(
            address, target, region
        )  # and not is_ascii_string(address, process)
    return code_bool


def is_stack(address: SBValue, process: SBProcess, regions: SBMemoryRegionInfoList) -> bool:
    """Determines whether an @address points to the stack"""
    if regions is None:
        return False
    region = SBMemoryRegionInfo()
    stack_bool = False
    if regions.GetMemoryRegionContainingAddress(address, region):
        if region.GetName() == "[stack]":
            stack_bool = True
    return stack_bool


def is_heap(address: SBValue, process: SBProcess, regions: SBMemoryRegionInfoList) -> bool:
    """Determines whether an @address points to the heap"""
    if regions is None:
        return False
    region = SBMemoryRegionInfo()
    heap_bool = False
    if regions.GetMemoryRegionContainingAddress(address, region):
        if region.GetName() == "[heap]":
            heap_bool = True
    return heap_bool


def extract_arch_from_triple(triple: str) -> str:
    """Extracts the architecture from triple string."""
    return triple.split("-")[0]


def check_version(required_version_string):
    def inner(func):
        def wrapper(*args, **kwargs):
            required_version = [int(x) for x in required_version_string.split(".")]
            if LLEFState.version < required_version:
                print(f"error: requires LLDB version {required_version_string} to execute")
                return
            return func(*args, **kwargs)

        return wrapper

    return inner


def check_process(func):
    """
    Checks that there's a running process before executing the wrapped function. Only to be used on
    overrides of `__call__`.

    :param func: Wrapped function to be executed after successful check.
    """

    def wrapper(*args, **kwargs):
        for arg in list(args) + list(kwargs.values()):
            if isinstance(arg, SBExecutionContext):
                if arg.process.is_alive:
                    return func(*args, **kwargs)

                print_message(MSG_TYPE.ERROR, "Requires a running process.")
                return

        print_message(MSG_TYPE.ERROR, "Execution context not found.")

    return wrapper


def check_target(func):
    def wrapper(*args, **kwargs):
        for arg in list(args) + list(kwargs.values()):
            if isinstance(arg, SBExecutionContext):
                if arg.target.IsValid():
                    return func(*args, **kwargs)

                print_message(MSG_TYPE.ERROR, "Requires a valid target.")
                return

        print_message(MSG_TYPE.ERROR, "Execution context not found.")

    return wrapper


def check_elf(func):
    def wrapper(*args, **kwargs):
        for arg in list(args) + list(kwargs.values()):
            if isinstance(arg, SBExecutionContext):
                try:
                    if read_program(arg.target, 0, 4) == b"\x7F\x45\x4C\x46":
                        return func(*args, **kwargs)
                    else:
                        print_message(MSG_TYPE.ERROR, "Target must be an ELF file.")
                        return
                except MemoryError:
                    print_message(MSG_TYPE.ERROR, "couldn't determine file type")
                    return

        print_message(MSG_TYPE.ERROR, "Execution context not found.")

    return wrapper


def hex_int(x):
    """A converter for input arguments in different bases to ints.
    For base 0, the base is determined by the prefix. So, numbers starting `0x` are hex
    and numbers with no prefix are decimal. Base 0 also disallows leading zeros.
    """
    return int(x, 0)


def read_program(target: SBTarget, offset: int, n: int):
    """
    Read @n bytes from a given @offset from the start of @target object file.

    :param target: The target object file.
    :param offset: The byte offset of the file to start reading from.
    :param n: The number of bytes to read from the offset.
    :return: The read bytes convert to an integer with little endianness.
    """

    error = SBError()
    # Executable has always been observed at module 0, but isn't specifically stated in docs.
    program_module = target.GetModuleAtIndex(0)
    address = program_module.GetObjectFileHeaderAddress()
    address.OffsetAddress(offset)
    data = target.ReadMemory(address, n, error)

    if error.Fail():
        raise MemoryError(f"Couldn't read memory at file offset {hex(address.GetOffset())}.")

    return data


def read_program_int(target: SBTarget, offset: int, n: int):
    """
    Read @n bytes from a given @offset from the start of @target object file,
    and convert to integer by little endian.

    :param target: The target object file.
    :param offset: The byte offset of the file to start reading from.
    :param n: The number of bytes to read from the offset.
    :return: The read bytes convert to an integer with little endianness.
    """

    data = read_program(target, offset, n)
    return int.from_bytes(data, "little")
